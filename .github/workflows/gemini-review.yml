name: Gemini File-based Review and Commit

on:
  push:
    # å…¨ã¦ã®ãƒ–ãƒ©ãƒ³ãƒã¸ã®ãƒ—ãƒƒã‚·ãƒ¥ã‚’ãƒˆãƒªã‚¬ãƒ¼ã¨ã—ã¾ã™ã€‚
    # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®ãƒ—ãƒƒã‚·ãƒ¥å…ˆã¯ ${{ github.ref_name }} ã§å‹•çš„ã«æ±ºå®šã•ã‚Œã¾ã™ã€‚
    
# ã‚³ãƒŸãƒƒãƒˆã¨ãƒ—ãƒƒã‚·ãƒ¥ã«å¿…è¦ãªæ¨©é™ã‚’è¨­å®š
permissions:
  contents: write

jobs:
  review_and_commit:
    runs-on: ubuntu-latest
    # UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç’°å¢ƒå…¨ä½“ã§çµ±ä¸€è¨­å®š
    env:
      LANG: ja_JP.UTF-8
      LC_ALL: ja_JP.UTF-8
    
    steps:
      - name: â¬‡ï¸ ãƒªãƒã‚¸ãƒˆãƒªã®ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
        uses: actions/checkout@v4
        with:
          # ãƒ—ãƒƒã‚·ãƒ¥ãƒãƒƒã‚¯ã®ãŸã‚ã«èªè¨¼æƒ…å ±ã‚’ä¿æŒ
          persist-credentials: true
          fetch-depth: 0 # å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ­£ç¢ºã«å–å¾—ã™ã‚‹ãŸã‚ã«å±¥æ­´å…¨ä½“ã‚’å–å¾—

      - name: ğŸ”§ Pythonã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ”§ Gemini CLIã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        run: |
          # PythonçµŒç”±ã§Google Generative AIã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
          pip install google-generativeai
          
          # geminiã‚³ãƒãƒ³ãƒ‰ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ä½œæˆ
          sudo tee /usr/local/bin/gemini > /dev/null << 'EOF'
          #!/usr/bin/env python3
          import sys
          import os
          import google.generativeai as genai
          
          def main():
              if len(sys.argv) < 2:
                  print("Usage: gemini ask <prompt> [--file-path <path>]", file=sys.stderr)
                  sys.exit(1)
              
              if sys.argv[1] != "ask":
                  print(f"Unknown command: {sys.argv[1]}", file=sys.stderr)
                  sys.exit(1)
              
              # APIã‚­ãƒ¼ã‚’å–å¾—
              api_key = os.getenv('GEMINI_API_KEY')
              if not api_key:
                  print("Error: GEMINI_API_KEY environment variable is not set", file=sys.stderr)
                  sys.exit(1)
              
              genai.configure(api_key=api_key)
              
              # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
              prompt = sys.argv[2] if len(sys.argv) > 2 else ""
              file_path = None
              
              if '--file-path' in sys.argv:
                  file_idx = sys.argv.index('--file-path')
                  if file_idx + 1 < len(sys.argv):
                      file_path = sys.argv[file_idx + 1]
              
              # ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’èª­ã¿è¾¼ã‚€
              file_content = ""
              if file_path:
                  if not os.path.exists(file_path):
                      print(f"Warning: File does not exist: {file_path}", file=sys.stderr)
                      print(f"Current working directory: {os.getcwd()}", file=sys.stderr)
                  else:
                      try:
                          with open(file_path, 'r', encoding='utf-8') as f:
                              file_content = f.read()
                          print(f"Successfully read file: {file_path} ({len(file_content)} bytes)", file=sys.stderr)
                      except Exception as e:
                          print(f"Error reading file {file_path}: {e}", file=sys.stderr)
              
              # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
              # file_pathãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãŸã¨ãˆãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’å«ã‚ã‚‹
              if file_path:
                  full_prompt = f"{prompt}\n\nFile: {file_path}\n\n```\n{file_content}\n```"
              else:
                  full_prompt = prompt
              
              # Gemini APIã‚’å‘¼ã³å‡ºã—
              model_name = 'gemini-2.5-flash'
              print(f"ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«: {model_name}", file=sys.stderr)
              model = genai.GenerativeModel(model_name)
              response = model.generate_content(full_prompt)
              print(f"ãƒ¢ãƒ‡ãƒ«ã®å‘¼ã³å‡ºã—å®Œäº†: {model_name}", file=sys.stderr)
              
              print(response.text)
          
          if __name__ == "__main__":
              main()
          EOF
          
          sudo chmod +x /usr/local/bin/gemini
        
      - name: ğŸ”§ Gitè¨­å®šï¼ˆéASCIIæ–‡å­—ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’ç„¡åŠ¹åŒ–ï¼‰
        run: |
          # éASCIIæ–‡å­—ï¼ˆæ—¥æœ¬èªãªã©ï¼‰ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œãªã„ã‚ˆã†ã«è¨­å®š
          git config --global core.quotepath false
        
      - name: ğŸ“‹ ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡æ‹¡å¼µå­ã®èª­ã¿è¾¼ã¿
        id: load-extensions
        run: |
          # CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ‹¡å¼µå­ã‚’èª­ã¿è¾¼ã‚“ã§file patternsã‚’ç”Ÿæˆ
          echo "extensions_pattern<<EOF" >> "$GITHUB_OUTPUT"
          tail -n +2 docs/target-extensions.csv | while read ext; do
            # ç©ºè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
            if [ -n "$ext" ]; then
              echo "**/*${ext}" >> "$GITHUB_OUTPUT"
            fi
          done
          echo "EOF" >> "$GITHUB_OUTPUT"
        
      - name: ğŸ” å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ç‰¹å®š
        id: changed-files
        uses: tj-actions/changed-files@v45
        with:
          # ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‹¡å¼µå­ã‚’è¨­å®š
          files: |
            ${{ steps.load-extensions.outputs.extensions_pattern }}
            !**/*.d.ts
          # éASCIIæ–‡å­—ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ­£ã—ãå‡¦ç†ã™ã‚‹ãŸã‚
          quotepath: false
          # ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å‡ºåŠ›ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚„ç‰¹æ®Šæ–‡å­—ã‚’å«ã‚€ãƒ•ã‚¡ã‚¤ãƒ«åã«å¯¾å¿œï¼‰
          separator: ","

      - name: "ğŸ” ãƒ‡ãƒãƒƒã‚°: å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®å‡ºåŠ›ç¢ºèª"
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          echo "--- all_changed_files ã®å‡ºåŠ› (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š) ---"
          echo "${{ steps.changed-files.outputs.all_changed_files }}"
          echo "------------------------------------"
          echo "ãƒ•ã‚¡ã‚¤ãƒ«æ•°: ${{ steps.changed-files.outputs.all_changed_files_count }}"

      - name: ğŸ”§ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®å¾©å…ƒå‡¦ç†ï¼ˆPythonï¼‰
        id: decode-files
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          python3 << 'EOF'
          import os
          import sys
          
          # ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€è¦§ã‚’å–å¾—
          raw = os.environ.get('CHANGED_FILES_RAW', '')
          if not raw:
              print("No files to decode", file=sys.stderr)
              sys.exit(0)
          
          # ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’ä½œæˆ
          # å„ãƒ•ã‚¡ã‚¤ãƒ«åã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼ˆ8é€²æ•°ï¼‰ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã¾ãŸã¯ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’é™¤å»
          files = []
          for f in raw.split(','):
              f = f.strip()
              if f:
                  # ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥+8é€²æ•°ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
                  try:
                      # unicode_escapeã§ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è§£é‡ˆã—ã€
                      # latin1çµŒç”±ã§ãƒã‚¤ãƒˆåˆ—ã¨ã—ã¦æ‰±ã„ã€UTF-8ã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰
                      decoded = bytes(f, 'utf-8').decode('unicode_escape').encode('latin1').decode('utf-8')
                      # ãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã‚‚ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯é™¤å»
                      # ï¼ˆGitãŒUTF-8æ–‡å­—ã®å‰ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ä»˜ã‘ã‚‹å ´åˆã®å¯¾å¿œï¼‰
                      if '\\' in decoded:
                          decoded = decoded.replace('\\', '')
                      files.append(decoded)
                  except Exception as e:
                      # ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸå ´åˆã¯ã€ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’é™¤å»ã—ã¦ä½¿ç”¨
                      print(f"Info: Decode failed for '{f}': {e}", file=sys.stderr)
                      cleaned = f.replace('\\', '')
                      print(f"Info: Using cleaned path: '{cleaned}'", file=sys.stderr)
                      files.append(cleaned)
          
          # ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’å‡ºåŠ›
          if files:
              with open('decoded_files.txt', 'w', encoding='utf-8') as out:
                  for f in files:
                      out.write(f + '\n')
              print(f"Successfully decoded {len(files)} file(s)", file=sys.stderr)
              for f in files:
                  print(f"  - {f}", file=sys.stderr)
          else:
              print("No files after decoding", file=sys.stderr)
          EOF
        env:
          CHANGED_FILES_RAW: ${{ steps.changed-files.outputs.all_changed_files }}

      - name: âš™ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®å®Ÿè¡Œã¨çµæœã®ä¿å­˜
        id: review_process
        # å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆã®ã¿å®Ÿè¡Œ
        if: steps.changed-files.outputs.any_changed == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          REVIEW_BASE_DIR: review # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’ä¿å­˜ã™ã‚‹ç‰¹å®šã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        run: |
          # GEMINI_API_KEYãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "Error: GEMINI_API_KEY is not set"
            exit 1
          fi
          # 1. å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æ±ºå®šã¨ä½œæˆ (yyyyMMddå½¢å¼ã€æ—¥æœ¬æ™‚é–“)
          REVIEW_DATE_DIR=$(TZ='Asia/Tokyo' date +"%Y%m%d")
          FULL_REVIEW_PATH="${REVIEW_BASE_DIR}/${REVIEW_DATE_DIR}"
          echo "ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: ${FULL_REVIEW_PATH}"
          mkdir -p $FULL_REVIEW_PATH

          REVIEW_COUNT=0
          
          # 2. å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ«ãƒ¼ãƒ—å‡¦ç†
          # Pythonã§ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‹ã‚‰èª­ã¿è¾¼ã‚€
          if [ ! -f "decoded_files.txt" ]; then
              echo "Error: decoded_files.txt not found"
              exit 1
          fi
          
          while IFS= read -r file; do
              # ç©ºã®ã‚¨ãƒ³ãƒˆãƒªã‚’ã‚¹ã‚­ãƒƒãƒ—
              if [ -z "$file" ]; then
                  continue
              fi

              # 3. ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æ±ºå®š (ä¾‹: path/to/file.ts -> file.md)
              filename=$(basename -- "$file")
              # æ‹¡å¼µå­ã‚’é™¤å»ã—ã€.mdã‚’è¿½åŠ 
              review_filename="${filename%.*}.md" 
              review_file_path="${FULL_REVIEW_PATH}/${review_filename}"
              
              echo "âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡: $file -> ${review_file_path}"
              
              # 4. Gemini CLIã‚’å®Ÿè¡Œã—ã€çµæœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
              # --file-pathã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’æ¸¡ã™
              gemini ask "$(cat docs/instruction-review.md)" --file-path "$file" > "$review_file_path"
              
              if [ $? -eq 0 ] && [ -s "$review_file_path" ]; then
                  # æˆåŠŸã‹ã¤ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒ0ã‚ˆã‚Šå¤§ãã„å ´åˆ
                  REVIEW_COUNT=$((REVIEW_COUNT + 1))
              else
                  echo "ğŸš¨ Gemini CLIã®å®Ÿè¡Œã«å¤±æ•—ã¾ãŸã¯ç©ºã®çµæœãŒè¿”ã•ã‚Œã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—ã¾ã™: $review_file_path"
                  rm -f "$review_file_path"
              fi
          done < "decoded_files.txt"
          
          # 5. ã‚³ãƒŸãƒƒãƒˆå¯¾è±¡ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«æ¸¡ã™
          if [ "$REVIEW_COUNT" -gt 0 ]; then
              echo "files_to_commit=${FULL_REVIEW_PATH}" >> "$GITHUB_OUTPUT"
          else
              # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒä¸€ã¤ã‚‚ç”Ÿæˆã•ã‚Œãªã‹ã£ãŸå ´åˆã€ç©ºã®æ–‡å­—åˆ—ã‚’è¨­å®šã—ã¦ã‚¹ã‚­ãƒƒãƒ—
              echo "files_to_commit=" >> "$GITHUB_OUTPUT"
          fi

      - name: ğŸš€ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®ã‚³ãƒŸãƒƒãƒˆã¨ãƒ—ãƒƒã‚·ãƒ¥
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœãŒ1ã¤ä»¥ä¸Šç”Ÿæˆã•ã‚ŒãŸå ´åˆã®ã¿å®Ÿè¡Œ
        if: steps.review_process.outputs.files_to_commit != ''
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'feat: Geminiã«ã‚ˆã‚‹è‡ªå‹•ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’è¿½åŠ  (${{ github.sha }})'
          # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœãŒä¿å­˜ã•ã‚ŒãŸ yyyyMMdd ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå…¨ä½“ã‚’ã‚³ãƒŸãƒƒãƒˆå¯¾è±¡ã¨ã™ã‚‹
          files: ${{ steps.review_process.outputs.files_to_commit }}
          # ãƒ—ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸãƒ–ãƒ©ãƒ³ãƒã¨åŒã˜ãƒ–ãƒ©ãƒ³ãƒã«ã‚³ãƒŸãƒƒãƒˆ
          branch: ${{ github.ref_name }} 
          commit_user_name: 'gemini-cli-reviewer[bot]' 
          commit_user_email: 'gemini-cli-reviewer[bot]@users.noreply.github.com'
          skip_ci: true
